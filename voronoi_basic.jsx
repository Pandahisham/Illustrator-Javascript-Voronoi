//  voronoi.jsx//  draws voronoi diagrams in illustrator//  using the javascript port from//  gorhill --> https://github.com/gorhill //  you can find the code here://  https://github.com/gorhill/Javascript-Voronoi//  under the same license as this one//  the illustrator usage can be found here://  https://github.com/fabiantheblind/Javascript-Voronoi//  the direct download is here: //  https://github.com/fabiantheblind/Javascript-Voronoi/zipball/master//Copyright (c)  2012 Fabian "fabiantheblind" Morón Zirfas//Permission is hereby granted, free of charge, to any person obtaining a copy of this//software and associated documentation files (the "Software"), to deal in the Software //without restriction, including without limitation the rights to use, copy, modify, //merge, publish, distribute, sublicense, and/or sell copies of the Software, and to //permit persons to whom the Software is furnished to do so, subject to the following //conditions://The above copyright notice and this permission notice shall be included in all copies //or substantial portions of the Software.//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, //INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A //PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT //HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF //CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE //OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.//see also http://www.opensource.org/licenses/mit-license.php#include "rhill-voronoi-core.js"main();function main(){  // this is the basic example by gorhillvar sites = [{x:300,y:300}, {x:100,y:100}, {x:200,y:500}, {x:250,y:450}, {x:500,y:150}];  // xl, xr means x left, x right  // yt, yb means y top, y bottomvar bbox = {xl:0, xr:800, yt:0, yb:600};var voronoi = new Voronoi();  // pass an object which exhibits xl, xr, yt, yb properties. The bounding  // box will be used to connect unbound edges, and to close open cells    result = voronoi.compute(sites, bbox);  // use this line below for object inspection // alert("\n"+util_insepct_properties(result));   // render, further analyze, etc.// build a preset for the new doc// i find this most convinent for creating documentsvar docPreset = new DocumentPreset;    docPreset.units = RulerUnits.Pixels; // use pixels// make it the size of the bounding box    docPreset.width = bbox.xr;    docPreset.height = bbox.yb;var doc = app.documents.addDocument("newFile",docPreset);    draw_edges (doc, result); // draws edges on own layer    draw_cells (doc,result); // draws cells on own layer}// ------------ Draw the cells ------------// this builds polygons for all cellsfunction draw_cells(d, result){var doc = d;// get the working docvar lyr = doc.layers.add(); // make a new layer    lyr.name = "cells";var cells = new Array(); // for holding Voronoi.cell obejctsfor(var i in result.cells){  // ------------ this is taken from gorhills example http://tinyurl.com/3vprrdh ------------  var cell = result.cells[i];// single it out  var halfedges = cell.halfedges;// get the list of halfedges in this object  var nHalfedges = halfedges.length;// the length  if (nHalfedges < 3) {continue;}// this is not enough for drawing a cell      var v = halfedges[0].getStartpoint();// get the first point      var pt = new Array(); // for holding the pathpoints          pt.push(new Array(v.x,v.y));// push the startpoint in      for (var iHalfedge=0; iHalfedge<nHalfedges; iHalfedge++) {            v = halfedges[iHalfedge].getEndpoint();// now just get the endpoint startpoint is the endpoint of the edge before            pt.push(new Array(v.x,v.y));// for the path        }// ------------ end of gorhills code ------------// style it a bit  var path = doc.pathItems.add(); // make a empty pathobject      path.setEntirePath(pt);// build the path      // this is for seeing whats going on  var color = new RGBColor();      color.red = Math.random()*255;      color.green = Math.random()*255;      color.blue = Math.random()*255;      path.strokeColor = color;      path.filled = true;      path.closed = true;      path.fillColor = color;      redraw(); // so you can see what happens  }draw_sites(doc, 3, result); }function draw_sites(doc, diam, result){for(var l in result.cells){    var top = -result.cells[l].site.y;    var left = result.cells[l].site.x;    var ell = doc.pathItems.ellipse( -top + diam/2, left -diam/2, diam, diam, true,true );    }}// ------------ draw edges only ------------// these are unconnected linesfunction draw_edges(doc, result){var lyr = doc.layers.add();// new layer    lyr.name = "edges";for(var i in result.edges){    var pt = new Array();// for the pathpoints    // get the 2 points that make up an edge    var va = new Array(result.edges[i].va.x, result.edges[i].va.y);    var vb = new Array(result.edges[i].vb.x, result.edges[i].vb.y);    // push them into an array        pt.push(new Array(va[0],va[1]));        pt.push(new Array(vb[0],vb[1]));    // now push them in our liat           var path = doc.pathItems.add();        path.setEntirePath(pt);// now build the path  }draw_sites(doc, 3, result);}// ------------ other peoples functions ------------// the functions below are// by Peter the Magnificant Kahrel// (a bit edited by me)// http://www.kahrel.plus.com/indesign/scriptui.html// look under "Displaying properties and methods"function  util_insepct_properties (f) {  var str = "";  try{str = f.reflect.name.toString() + " "+ f.reflect.name;// $.writeln (f.reflect.name);var props = f.reflect.properties;var array = [];for (var i = 0; i < props.length; i++)try {array.push (props[i].name + ": " + f[props[i].name])} catch (_){} array.sort ();str = str + "\n" + (array.join ("\r"));// $.writeln (array.join ("\r");}catch(e){}return str;}function util_inspect_methods (m) {var props = m.reflect.methods.sort(); $.writeln ("\rMethods");for (var i = 0; i < props.length; i++)$.writeln (props[i].name);}